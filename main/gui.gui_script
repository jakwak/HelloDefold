local npc_count = 0
local online_players = {}
local score_nodes = {} -- 생성된 노드들을 저장할 테이블

-- 모델 설정
local models = { "model1", "model2", "model3", "model4" }

-- npcs 텍스트를 화면 한 가운데 꼭대기에 정렬하는 함수
local function arrange_npcs_text(self)
	local screen_width = gui.get_width()
	local screen_height = gui.get_height()

	if self.npcs_node then
		-- 화면 가운데 상단에 배치 (상단에서 약간 아래로)
		gui.set_position(self.npcs_node, vmath.vector3(screen_width - 50, screen_height - 20, 0))
		-- 텍스트 중앙 정렬
		gui.set_pivot(self.npcs_node, gui.PIVOT_CENTER)
	end
end

local function arrange_point(self)
	local screen_width = gui.get_width()
	local screen_height = gui.get_height()

	if self.point then
		gui.set_position(self.point, vmath.vector3(screen_width / 2, screen_height - 20, 0))
		gui.set_pivot(self.point, gui.PIVOT_CENTER)
	end
end

-- 모델 노드들을 가로로 한 줄 정렬하는 함수
local function arrange_models_horizontal(self)
	local screen_width = gui.get_width()
	local screen_height = gui.get_height()

	local spacing = 200                             -- 모델 간 간격
	local total_width = (#models - 1) * spacing     -- 전체 너비 계산
	local start_x = (screen_width - total_width) / 2 -- 시작 x 위치 (중앙 정렬)

	for i, model in ipairs(models) do
		if self.nodes[model] then
			gui.set_position(self.nodes[model], vmath.vector3(start_x + (i - 1) * spacing, screen_height / 2, 0))
		end
	end
end

local function arrange_models_responsive(self)
	local screen_width = gui.get_width()
	local screen_height = gui.get_height()

	-- 화면 크기에 따라 간격 조정
	local spacing_x = math.min(300, screen_width * 0.2)
	local spacing_y = math.min(200, screen_height * 0.2)

	local positions = {
		{ x = screen_width / 2 - spacing_x / 2, y = screen_height / 2 + spacing_y / 2 },
		{ x = screen_width / 2 + spacing_x / 2, y = screen_height / 2 + spacing_y / 2 },
		{ x = screen_width / 2 - spacing_x / 2, y = screen_height / 2 - spacing_y / 2 },
		{ x = screen_width / 2 + spacing_x / 2, y = screen_height / 2 - spacing_y / 2 }
	}

	for i, model in ipairs(models) do
		if self.nodes[model] then
			gui.set_position(self.nodes[model], vmath.vector3(positions[i].x, positions[i].y, 0))
		end
	end
end

-- 동적으로 텍스트 노드 생성 (함수를 먼저 선언)
local function create_score_nodes(self)
	-- 기존 노드들 제거
	for _, node in ipairs(score_nodes) do
		gui.delete_node(node)
	end
	score_nodes = {}

	-- 화면 크기 가져오기
	local screen_width = gui.get_width()
	local screen_height = gui.get_height()

	-- 새로운 노드들 생성
	local start_y = screen_height - 100 -- 상단에서 100픽셀 아래
	local spacing = 30                 -- 노드 간 간격

	-- for i = 1, #online_players do
		print("online_players", online_players["player1"].name, online_players["player1"].point)
		-- 새로운 텍스트 노드 생성
		local node = gui.new_text_node(vmath.vector3(20, 400, 0), "Player ")

		-- 노드 속성 설정
		gui.set_pivot(node, gui.PIVOT_NW)
		gui.set_scale(node, vmath.vector3(1, 1, 1))
		gui.set_color(node, vmath.vector4(1, 0, 0, 1)) -- 빨간색으로 설정
		gui.set_font(node, "korean")

		-- 노드 크기 설정
		gui.set_size(node, vmath.vector3(200, 30, 0))

		-- 노드 저장
		table.insert(score_nodes, node)

		-- 디버그용 출력
		print("Created node at position:", 400)
	-- end
end

-- 온라인 플레이어 점수 표시 업데이트
local function update_online_scores(self)
	-- 플레이어 정보를 점수 순으로 정렬
	local sorted_players = {}
	for player_id, player_info in pairs(online_players) do
		table.insert(sorted_players, {
			id = player_id,
			name = player_info.name,
			point = player_info.point
		})
	end

	-- 점수 순으로 정렬
	table.sort(sorted_players, function(a, b)
		return a.point > b.point
	end)

	-- 노드 수가 부족하면 추가 생성
	if #score_nodes < #sorted_players then
		create_score_nodes(self)
	end

	-- 각 노드에 플레이어 정보 표시
	for i, player in ipairs(sorted_players) do
		if score_nodes[i] then
			local score_text = string.format("%d. %s: %d",
				i,
				player.name,
				player.point
			)
			gui.set_text(score_nodes[i], score_text)
			gui.set_enabled(score_nodes[i], true)           -- 노드 활성화
			print("Updated node", i, "with text:", score_text) -- 디버그용 출력
		end
	end

	-- 사용하지 않는 노드 숨기기
	for i = #sorted_players + 1, #score_nodes do
		if score_nodes[i] then
			gui.set_enabled(score_nodes[i], false)
		end
	end
end

function init(self)
	self.npcs_node = gui.get_node("npcs")
	gui.set_text(self.npcs_node, "NPCs: " .. npc_count)
	self.point = gui.get_node("point")
	gui.set_text(self.point, "Point: 0")

	-- 모델 노드와 상태 초기화
	self.nodes = {}
	self.hovered = {}

	for _, model in ipairs(models) do
		self.nodes[model] = gui.get_node(model)
		self.hovered[model] = false
	end

	arrange_npcs_text(self)
	arrange_point(self)
	arrange_models_horizontal(self)

	-- 테스트용 플레이어 데이터 추가
	online_players = {
		player1 = { name = "Player 1", point = 100 },
		player2 = { name = "Player 2", point = 200 },
		player3 = { name = "Player 3", point = 300 }
	}

	-- 초기 노드들 생성
	create_score_nodes(self)
	-- update_online_scores(self)

	msg.post(".", "acquire_input_focus")
end

-- 온라인 플레이어 정보 업데이트
function on_message(self, message_id, message, sender)
	if message_id == hash("npc_add") then
		npc_count = npc_count + 1
		gui.set_text(self.npcs_node, "NPCs: " .. npc_count)
	elseif message_id == hash("npc_remove") then
		npc_count = npc_count - 1
		gui.set_text(self.npcs_node, "NPCs: " .. npc_count)
	elseif message_id == hash("point_update") then
		gui.set_text(self.point, "Point: " .. message.point)
	elseif message_id == hash("online_player_update") then
		online_players[message.player_id] = {
			name = message.name,
			point = message.point
		}
		update_online_scores(self)
	end
end

function on_input(self, action_id, action)
	if not action or not action.x or not action.y then return end

	-- 클릭 처리
	if action_id == hash("touch") and action.pressed then
		for _, model in ipairs(models) do
			if gui.pick_node(self.nodes[model], action.x, action.y) then
				msg.post("managers#global_network", "player_type", { type = model })

				-- 모든 모델 숨기기
				for _, m in ipairs(models) do
					gui.animate(self.nodes[m], "color.w", 0, gui.EASING_LINEAR, 0.5, 0, function()
						gui.set_enabled(self.nodes[m], false)
					end)
				end
				break
			end
		end
	end

	-- 마우스 오버 처리
	for _, model in ipairs(models) do
		local is_over = gui.pick_node(self.nodes[model], action.x, action.y)

		if is_over and not self.hovered[model] then
			self.hovered[model] = true
			gui.animate(self.nodes[model], "scale", vmath.vector3(1.2, 1.2, 1), gui.EASING_OUTQUAD, 0.2)
		elseif not is_over and self.hovered[model] then
			self.hovered[model] = false
			gui.animate(self.nodes[model], "scale", vmath.vector3(1, 1, 1), gui.EASING_OUTQUAD, 0.2)
		end
	end
end

function on_reload(self)
	print("GUI script reloaded")
	create_score_nodes(self)
	update_online_scores(self)
end

-- 노드 정리
function final(self)
	for _, node in ipairs(score_nodes) do
		gui.delete_node(node)
	end
end

function update(self, dt)
	-- if room == nil then
	-- 	room = _G.network_room
	-- 	if room then
	-- 		room:on_message("npc_count", function(message)
	-- 			gui.set_text(gui.get_node("npcs"), "NPCs: " .. message.count)
	-- 		end)
	-- 	end
	-- end
end
