local npc_count = 0

-- 모델 설정
local models = { "model1", "model2", "model3", "model4" }

-- npcs 텍스트를 화면 한 가운데 꼭대기에 정렬하는 함수
local function arrange_npcs_text_top_center(self)
	local screen_width = gui.get_width()
	local screen_height = gui.get_height()

	if self.npcs_node then
		-- 화면 가운데 상단에 배치 (상단에서 약간 아래로)
		gui.set_position(self.npcs_node, vmath.vector3(screen_width / 2, screen_height - 20, 0))
		-- 텍스트 중앙 정렬
		gui.set_pivot(self.npcs_node, gui.PIVOT_CENTER)
	end
end

-- 모델 노드들을 가로로 한 줄 정렬하는 함수
local function arrange_models_horizontal(self)
	local screen_width = gui.get_width()
	local screen_height = gui.get_height()

	local spacing = 200                             -- 모델 간 간격
	local total_width = (#models - 1) * spacing     -- 전체 너비 계산
	local start_x = (screen_width - total_width) / 2 -- 시작 x 위치 (중앙 정렬)

	for i, model in ipairs(models) do
		if self.nodes[model] then
			gui.set_position(self.nodes[model], vmath.vector3(start_x + (i - 1) * spacing, screen_height / 2, 0))
		end
	end
end

local function arrange_models_responsive(self)
	local screen_width = gui.get_width()
	local screen_height = gui.get_height()

	-- 화면 크기에 따라 간격 조정
	local spacing_x = math.min(300, screen_width * 0.2)
	local spacing_y = math.min(200, screen_height * 0.2)

	local positions = {
		{ x = screen_width / 2 - spacing_x / 2, y = screen_height / 2 + spacing_y / 2 },
		{ x = screen_width / 2 + spacing_x / 2, y = screen_height / 2 + spacing_y / 2 },
		{ x = screen_width / 2 - spacing_x / 2, y = screen_height / 2 - spacing_y / 2 },
		{ x = screen_width / 2 + spacing_x / 2, y = screen_height / 2 - spacing_y / 2 }
	}

	for i, model in ipairs(models) do
		if self.nodes[model] then
			gui.set_position(self.nodes[model], vmath.vector3(positions[i].x, positions[i].y, 0))
		end
	end
end


function init(self)
	self.npcs_node = gui.get_node("npcs")
	gui.set_text(self.npcs_node, "NPCs: " .. npc_count)

	-- 모델 노드와 상태 초기화
	self.nodes = {}
	self.hovered = {}

	for _, model in ipairs(models) do
		self.nodes[model] = gui.get_node(model)
		self.hovered[model] = false
	end

	arrange_npcs_text_top_center(self)
	arrange_models_horizontal(self)

	msg.post(".", "acquire_input_focus")
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- if room == nil then
	-- 	room = _G.network_room
	-- 	if room then
	-- 		room:on_message("npc_count", function(message)
	-- 			gui.set_text(gui.get_node("npcs"), "NPCs: " .. message.count)
	-- 		end)
	-- 	end
	-- end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("npc_add") then
		npc_count = npc_count + 1
	elseif message_id == hash("npc_remove") then
		npc_count = npc_count - 1
	end
	gui.set_text(gui.get_node("npcs"), "NPCs: " .. npc_count)
end

function on_input(self, action_id, action)
	if not action or not action.x or not action.y then return end

	-- 클릭 처리
	if action_id == hash("touch") and action.pressed then
		for _, model in ipairs(models) do
			if gui.pick_node(self.nodes[model], action.x, action.y) then
				msg.post("managers#global_network", "player_type", { type = model })

				-- 모든 모델 숨기기
				for _, m in ipairs(models) do
					gui.animate(self.nodes[m], "color.w", 0, gui.EASING_LINEAR, 0.5, 0, function()
						gui.set_enabled(self.nodes[m], false)
					end)
				end
				break
			end
		end
	end

	-- 마우스 오버 처리
	for _, model in ipairs(models) do
		local is_over = gui.pick_node(self.nodes[model], action.x, action.y)

		if is_over and not self.hovered[model] then
			self.hovered[model] = true
			gui.animate(self.nodes[model], "scale", vmath.vector3(1.2, 1.2, 1), gui.EASING_OUTQUAD, 0.2)
		elseif not is_over and self.hovered[model] then
			self.hovered[model] = false
			gui.animate(self.nodes[model], "scale", vmath.vector3(1, 1, 1), gui.EASING_OUTQUAD, 0.2)
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
