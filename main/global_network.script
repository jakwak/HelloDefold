-- ì „ì—­ ë„¤íŠ¸ì›Œí¬ ê´€ë¦¬ì
local Colyseus = require "colyseus.sdk"
local utils = require "main.utils"

-- ì„œë²„ ì—°ê²° ì„¤ì •
-- local SERVER_URL = "gxg.kro.kr/game-server/"
local SERVER_URL = "ws://localhost:2567"
local ROOM_NAME = "matter_room"

-- ì „ì—­ ë³€ìˆ˜ë“¤
_G.network_room = nil        -- ì „ì—­ room ë³€ìˆ˜
_G.network_connected = false -- ì—°ê²° ìƒíƒœ
_G.my_session_id = nil       -- ë‚´ ì„¸ì…˜ ID
_G.players = {}              -- í”Œë ˆì´ì–´ ëª©ë¡

-- ë¡œì»¬ ìƒíƒœ
local reconnect_timer = nil
local reconnect_delay = 3.0
local previous_state = nil

-- ì‹œì‘ ìœ„ì¹˜ ì„¤ì • (ì˜µì…˜)
local join_options = {
  -- x = 480,  -- ì›í•˜ëŠ” ì‹œì‘ x ì¢Œí‘œ (ì£¼ì„ í•´ì œí•˜ë©´ ì‚¬ìš©)
  -- y = 320,   -- ì›í•˜ëŠ” ì‹œì‘ y ì¢Œí‘œ (ì£¼ì„ í•´ì œí•˜ë©´ ì‚¬ìš©)
  username = utils.get_username()
}

function init(self)
  print("=== Global Network Manager Started ===")

  -- ì´ˆê¸°í™”
  _G.network_room = nil
  _G.network_connected = false
  _G.my_session_id = nil
  _G.players = {}

  -- ì„œë²„ ì ‘ì† ì‹œë„
  -- connect_to_server()
end

-- HTML5ì—ì„œ hostname ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜
local function get_html5_hostname()
  local info = sys.get_sys_info()
  if info.system_name == "HTML5" then
    -- JavaScriptë¥¼ ì‹¤í–‰í•˜ì—¬ í˜„ì¬ hostname ê°€ì ¸ì˜¤ê¸°
    local hostname = html5.run("window.location.hostname")
    local protocol = html5.run("window.location.protocol")
    local port = html5.run("window.location.port")
    
    print("í˜„ì¬ hostname:", hostname)
    print("í˜„ì¬ protocol:", protocol)
    print("í˜„ì¬ port:", port)
    
    return hostname, protocol, port
  end
  return nil, nil, nil
end

function connect_to_server()
  print("ì„œë²„ ì ‘ì† ì‹œë„:", SERVER_URL, "ë£¸:", ROOM_NAME)

  local hostname, protocol, port = get_html5_hostname()

  local client = nil

  if hostname == "gxg.kro.kr" then
    client = Colyseus.Client({hostname = "gxg.kro.kr/game-server/", use_ssl = true, port = 443})
  else
    client = Colyseus.Client("ws://localhost:2567")
  end

  client:join_or_create(ROOM_NAME, join_options, function(err, room)
    if err then
      print("ì„œë²„ ì ‘ì† ì‹¤íŒ¨:", err.message)
      schedule_reconnect()
      return
    end

    print("ì„œë²„ ì ‘ì† ì„±ê³µ! ì„¸ì…˜ ID:", room.session_id)

    -- ì „ì—­ ë³€ìˆ˜ ì„¤ì •
    _G.network_room = room
    _G.network_connected = true
    _G.my_session_id = room.session_id

    -- ë£¸ ì´ë²¤íŠ¸ ì„¤ì •
    -- setup_room_events(room)

    room:on("error", function(code, message)
      print("ë£¸ ì—ëŸ¬:", message)
      cleanup_connection()
      schedule_reconnect()
    end)

    room:on("leave", function()
      print("ë£¸ì—ì„œ ë‚˜ê°.")
      cleanup_connection()
    end)

    utils.broadcast("network_connected", {
      room_id = room.session_id,
      session_id = room.session_id
    })
  end)
end

function on_message(self, message_id, message, sender)
  if message_id == hash("register_listener") then
    utils.register_listener(message.id)
  end
  if message_id == hash("factory_created") and _G.network_connected then
    msg.post(sender, "network_connected")
  end
  if message_id == hash("player_type") then
    join_options.type = message.type
    connect_to_server()
  end
end

-- function setup_room_events(room)
--   room:on("error", function(code, message)
--     print("ë£¸ ì—ëŸ¬:", message)
--     cleanup_connection()
--     schedule_reconnect()
--   end)

--   room:on("leave", function()
--     print("ë£¸ì—ì„œ ë‚˜ê°.")
--     cleanup_connection()
--   end)

--   -- room:on_message("*", function(message_type, message)
--   --   print("*** message_type: ", message_type)
--   --   handle_server_message(message_type, message)
--   -- end)

--   local callbacks = Colyseus.callbacks(room)

--   -- í”Œë ˆì´ì–´ ì¶”ê°€
--   callbacks:on_add("players", function(player, session_id)
--     print("í”Œë ˆì´ì–´ ì¶”ê°€ë¨:", session_id)

--     if not _G.players[session_id] then
--       _G.players[session_id] = {}
--     end

--     -- í”Œë ˆì´ì–´ ë°ì´í„° ë³€ê²½ ê°ì§€
--     callbacks:listen(player, "x", function(cur_val, prev_val)
--       if not _G.players[session_id] then
--         _G.players[session_id] = {}
--       end
--       _G.players[session_id].x = cur_val

--       -- ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
--       utils.broadcast("player_position_update", {
--         session_id = session_id,
--         x = cur_val,
--         y = _G.players[session_id].y or 0,
--         is_my_player = session_id == _G.my_session_id
--       })
--     end)

--     callbacks:listen(player, "y", function(cur_val, prev_val)
--       if not _G.players[session_id] then
--         _G.players[session_id] = {}
--       end
--       _G.players[session_id].y = cur_val

--       -- ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
--       utils.broadcast("player_position_update", {
--         session_id = session_id,
--         x = _G.players[session_id].x or 0,
--         y = cur_val,
--         is_my_player = session_id == _G.my_session_id
--       })
--     end)

--     callbacks:listen(player, "name", function(cur_val, prev_val)
--       if not _G.players[session_id] then
--         _G.players[session_id] = {}
--       end
--       _G.players[session_id].name = cur_val

--       -- ì´ë¦„ ì—…ë°ì´íŠ¸ ë¸Œë¡œë“œìºìŠ¤íŠ¸
--       utils.broadcast("player_name_update", {
--         session_id = session_id,
--         name = cur_val,
--         is_my_player = session_id == _G.my_session_id
--       })
--     end)
--   end)

--   -- í”Œë ˆì´ì–´ ì œê±°
--   callbacks:on_remove("players", function(player, session_id)
--     print("í”Œë ˆì´ì–´ ì œê±°ë¨:", session_id)
--     _G.players[session_id] = nil

--     utils.broadcast("player_removed", {
--       session_id = session_id
--     })
--   end)
-- end

-- function handle_server_message(message_type, message)
--   print("ì„œë²„ ë©”ì‹œì§€ ìˆ˜ì‹ :", message_type)

--   if message_type == "debug_bodies" then
--     print("debug_bodies: ", message.bodies)
--     -- ë””ë²„ê·¸ ë°”ë”” ì •ë³´ ë¸Œë¡œë“œìºìŠ¤íŠ¸
--     utils.broadcast("debug_bodies_update", {
--       bodies = message.bodies or {}
--     })
--   elseif message_type == "move_response" then
--     print("move_response: ", message.x, message.y)
--     -- ì´ë™ ì‘ë‹µ ë¸Œë¡œë“œìºìŠ¤íŠ¸
--     utils.broadcast("move_response", message)
--   elseif message_type == "pad_position_response" then
--     print("pad_position_response: ", message.x, message.y)
--     -- íŒ¨ë“œ ìœ„ì¹˜ ì‘ë‹µ ë¸Œë¡œë“œìºìŠ¤íŠ¸
--     utils.broadcast("pad_position_update", message)
--   else
--     print("server_message: ", message_type)
--     -- ê¸°íƒ€ ë©”ì‹œì§€ë“¤ì„ ê·¸ëŒ€ë¡œ ë¸Œë¡œë“œìºìŠ¤íŠ¸
--     utils.broadcast("server_message", {
--       type = message_type,
--       data = message
--     })
--   end
-- end

-- function broadcast_message(msg_type, data)
--   -- ëª¨ë“  ê²Œì„ ì˜¤ë¸Œì íŠ¸ì—ê²Œ ë©”ì‹œì§€ ë¸Œë¡œë“œìºìŠ¤íŠ¸
--   local safe_data = data or {}

--   print("ğŸ“¡ ë¸Œë¡œë“œìºìŠ¤íŠ¸:", msg_type)

--   -- ì‹œìŠ¤í…œ ì „ì²´ì— ë¸Œë¡œë“œìºìŠ¤íŠ¸
--   msg.post("@system:", msg_type, safe_data)

--   -- ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ” ê²Œì„ ì˜¤ë¸Œì íŠ¸ë“¤ì—ê²Œë§Œ ì „ì†¡
--   local targets = {
--     "/test_manager#test" -- test.script (ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ” ê²½ë¡œ)
--   }

--   for _, target in ipairs(targets) do
--     local success, error_msg = pcall(function()
--       msg.post(target, msg_type, safe_data)
--     end)
--     if success then
--       print("  âœ…", target)
--     else
--       print("  âŒ", target, "- ì—ëŸ¬:", error_msg)
--     end
--   end
-- end

function cleanup_connection()
  _G.network_room = nil
  _G.network_connected = false
  _G.my_session_id = nil
  _G.players = {}
end

function schedule_reconnect()
  if reconnect_timer then
    timer.cancel(reconnect_timer)
  end

  reconnect_timer = timer.delay(reconnect_delay, false, function()
    print("ì¬ì ‘ì† ì‹œë„ ì¤‘...")
    connect_to_server()
  end)
end

-- function on_message(self, message_id, message, sender)
--   if message_id == hash("send_move") then
--     -- ì´ë™ ëª…ë ¹ ì„œë²„ë¡œ ì „ì†¡
--     if _G.network_room and _G.network_connected then
--       _G.network_room:send("move", message)
--     else
--       print("ë„¤íŠ¸ì›Œí¬ì— ì—°ê²°ë˜ì§€ ì•ŠìŒ - ì´ë™ ëª…ë ¹ ë¬´ì‹œ")
--     end
--   elseif message_id == hash("send_position") then
--     -- ìœ„ì¹˜ ì •ë³´ ì„œë²„ë¡œ ì „ì†¡
--     if _G.network_room and _G.network_connected then
--       _G.network_room:send("position_sync", message)
--     else
--       print("ë„¤íŠ¸ì›Œí¬ì— ì—°ê²°ë˜ì§€ ì•ŠìŒ - ìœ„ì¹˜ ë™ê¸°í™” ë¬´ì‹œ")
--     end
--   elseif message_id == hash("request_debug_bodies") then
--     -- ë””ë²„ê·¸ ë°”ë”” ì •ë³´ ìš”ì²­
--     if _G.network_room and _G.network_connected then
--       _G.network_room:send("get_debug_bodies", {})
--     else
--       print("ë„¤íŠ¸ì›Œí¬ì— ì—°ê²°ë˜ì§€ ì•ŠìŒ - ë””ë²„ê·¸ ë°”ë”” ìš”ì²­ ë¬´ì‹œ")
--     end
--   elseif message_id == hash("update_pad_position") then
--     -- íŒ¨ë“œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
--     if _G.network_room and _G.network_connected then
--       _G.network_room:send("pad_position", message)
--     else
--       print("ë„¤íŠ¸ì›Œí¬ì— ì—°ê²°ë˜ì§€ ì•ŠìŒ - íŒ¨ë“œ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ë¬´ì‹œ")
--     end
--   elseif message_id == hash("get_network_state") then
--     -- ë„¤íŠ¸ì›Œí¬ ìƒíƒœ ìš”ì²­ì— ì‘ë‹µ
--     msg.post(sender, "network_state_response", {
--       connected = _G.network_connected,
--       session_id = _G.my_session_id,
--       players = _G.players,
--       room_available = _G.network_room ~= nil
--     })
--   elseif message_id == hash("disconnect") then
--     -- ìˆ˜ë™ ì—°ê²° í•´ì œ
--     if _G.network_room then
--       _G.network_room:leave()
--     end
--     cleanup_connection()
--   elseif message_id == hash("reconnect") then
--     -- ìˆ˜ë™ ì¬ì ‘ì†
--     cleanup_connection()
--     connect_to_server()
--   elseif message_id == hash("send_custom_message") then
--     -- ì»¤ìŠ¤í…€ ë©”ì‹œì§€ ì „ì†¡
--     if _G.network_room and _G.network_connected then
--       _G.network_room:send(message.type or "custom", message.data or {})
--     else
--       print("ë„¤íŠ¸ì›Œí¬ì— ì—°ê²°ë˜ì§€ ì•ŠìŒ - ì»¤ìŠ¤í…€ ë©”ì‹œì§€ ë¬´ì‹œ")
--     end
--   end
-- end

function final(self)
  print("Global Network Manager ì¢…ë£Œ ì¤‘...")

  if reconnect_timer then
    timer.cancel(reconnect_timer)
  end

  if _G.network_room then
    _G.network_room:leave()
  end

  cleanup_connection()
  print("Global Network Manager ì¢…ë£Œ ì™„ë£Œ")
end

-- ì „ì—­ í—¬í¼ í•¨ìˆ˜ë“¤
function _G.send_to_server(message_type, data)
  if _G.network_room and _G.network_connected then
    _G.network_room:send(message_type, data or {})
    return true
  end
  return false
end
