local Colyseus = require "colyseus.sdk"
local utils = require "main.utils"
local camera = require "orthographic.camera"

local room = nil

function init(self)
	msg.post(".", "acquire_input_focus") -- 입력 포커스 획득
	self.target_dir = vmath.vector3(0, 1, 0) -- 위쪽(y+)을 기본 방향으로!
	self.target_pos = nil
	self.current_angle = math.pi / 2 -- 90도(라디안)로 초기화

	self.sprite_id = factory.create("#factory", vmath.vector3(0, 0, 0))
	go.set_parent(self.sprite_id, go.get_id(), false)  -- false = 상대좌표 유지
	go.set_rotation(vmath.quat_rotation_z(self.current_angle), self.sprite_id)
	
	-- 큰 비행기 스프라이트 비활성화
	msg.post(msg.url(nil, self.sprite_id, "airplane2_sprite"), "disable")
	msg.post(msg.url("#sprite"), "disable")

	msg.post("camera", camera.MSG_BOUNDS, {
		right = 2000,
		top = 2000,
		left = 0,
		bottom = 0
	})
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	if self.target_pos then
		local current_pos = go.get_position()
		local new_pos = vmath.lerp(0.1, current_pos, self.target_pos) -- 부드럽게 이동
		go.set_position(new_pos)

		-- 목표 각도 계산
		local target_angle = math.atan2(self.target_dir.y, self.target_dir.x) - math.pi/2
		-- 현재 각도와 목표 각도 사이를 slerp로 보간
		-- 각도 wrap-around(2파이 넘는 문제) 보정
		local function angle_lerp(a, b, t)
			local diff = (b - a + math.pi) % (2 * math.pi) - math.pi
			return a + diff * t
		end

		self.current_angle = angle_lerp(self.current_angle, target_angle, 0.15) -- 0.1~0.2 정도가 자연스러움
		go.set_rotation(vmath.quat_rotation_z(self.current_angle), self.sprite_id)
	end

	if room == nil then
		room = _G.network_room
		if room then
			local callbacks = Colyseus.callbacks(room)
			callbacks:on_add("players", function(player, session_id)
				if session_id == room.session_id then
					callbacks:listen(player, "x", function(cur_val, prev_val)
						if not self.target_pos then
							self.target_pos = go.get_position()
						end
						self.target_pos.x = cur_val
					end)
					callbacks:listen(player, "y", function(cur_val, prev_val)
						if not self.target_pos then
							self.target_pos = go.get_position()
						end
						self.target_pos.y = cur_val
					end)
				end
			end)
		end
	end
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)

	if message_id == hash("set_player_info") then
		if message.username then
			self.username = message.username
			label.set_text("#label", tostring(self.username))
		end
		if message.size then
			self.size = message.size
			go.set("#sprite", "scale", vmath.vector3(self.size/32 * 4, self.size/32 * 4, 1))
		end
		if message.color then
			self.color = message.color
			go.set("#sprite", "tint", utils.hex_to_v4(tostring(self.color)))
		end
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		local screen_pos = vmath.vector3(action.x, action.y, 0)
		local world_pos = camera.screen_to_world(nil, screen_pos)
		local obj_pos = go.get_position()
		local dir = vmath.normalize(world_pos - obj_pos)
		self.target_dir = dir
		if room then
			room:send("move", { x = dir.x, y = dir.y })
			room:send("shoot_bullet", { x = world_pos.x, y = world_pos.y, dirx = dir.x, diry = dir.y, power = 10, velocity = 1, owner_id = room.session_id })
		end
		return true
	end

	return false
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end
