-- 플레이어 로직 (네트워크 포함)
local colyseus_client = require "network.colyseus_client"
local debug_mod = require "player2.player2_debug"
local debug_draw = nil
local setup_debug_callbacks = nil
local colyseus = require "colyseus.sdk"

local move_vector = { x = 0, y = 0 }
local keys = {
    [hash("up")] = { axis = "y", value = -1 },
    [hash("down")] = { axis = "y", value = 1 },
    [hash("left")] = { axis = "x", value = -1 },
    [hash("right")] = { axis = "x", value = 1 }
}

local debug_draw_enabled = true -- F1로 토글할 디버그 드로우 플래그

local function reset_inputs()
    move_vector.x = 0
    move_vector.y = 0
    if colyseus_client.room then
        colyseus_client.room:send("move", { x = 0, y = 0 })
    end
end

function init(self)
    msg.post(".", "release_input_focus")
    self.is_controllable = false
    self.input_enabled = false
    self.player_ready = false
    self.debug_timer = 0
    reset_inputs()
    msg.post("@render:", "use_fixed_fit_projection", { near = -1, far = 1 })
    colyseus_client.connect(
        "ws://localhost:2567", "matter_room",
        function(room)
            self.room = room
            self.is_connected = true
            print("Joined room:", room.session_id)
            reset_inputs()
            setup_room_callbacks(self)
            room:send("toggle_debug", { enabled = true })
        end,
        {
            update_pad_position = function(message)
                msg.post("/pad#pad_script", "update_pad_position", { x = message.x, y = message.y })
            end
        }
    )
    timer.delay(2.5, false, function()
        if not self.input_enabled then
            self.input_enabled = true
            msg.post(".", "acquire_input_focus")
            print("Input enabled after delay")
        end
    end)
end

function setup_room_callbacks(self)
    if not self.room then return end
    local room_callbacks = colyseus.callbacks(self.room)
    debug_draw, setup_debug_callbacks = debug_mod(self, room_callbacks)
    setup_debug_callbacks()
    room_callbacks:on_add("players", function(player, sessionId)
        print("New player joined:", sessionId)
        if sessionId == self.room.session_id then
            self.my_id = sessionId
            self.player = player
        end
        setup_player_callbacks(self, player, sessionId)
    end)
    room_callbacks:on_remove("players", function(player, sessionId)
        print("Player left:", sessionId)
    end)
end

function setup_player_callbacks(self, player, sessionId)
    if not self.room then return end
    local room_callbacks = colyseus.callbacks(self.room)
    if sessionId == self.room.session_id and player.x ~= nil and player.y ~= nil then
        msg.post("#player2_movement", "update_position", {
            x = player.x,
            y = player.y,
            is_controllable = player.isControllable
        })
    end
    room_callbacks:listen(player, "x", function(curVal, prevVal)
        if sessionId == self.room.session_id and self.player_ready then
            msg.post("#player2_movement", "update_position", {
                x = curVal,
                y = player.y,
                is_controllable = player.isControllable
            })
        end
    end)
    room_callbacks:listen(player, "y", function(curVal, prevVal)
        if sessionId == self.room.session_id and self.player_ready then
            msg.post("#player2_movement", "update_position", {
                x = player.x,
                y = curVal,
                is_controllable = player.isControllable
            })
        end
    end)
    room_callbacks:listen(player, "isControllable", function(curVal, prevVal)
        if sessionId == self.room.session_id then
            print("isControllable changed:", prevVal, "->", curVal)
            if curVal ~= self.is_controllable then
                self.is_controllable = curVal
                reset_inputs()
                if self.player_ready then
                    msg.post("#player2_movement", "update_position", {
                        x = player.x,
                        y = player.y,
                        is_controllable = curVal
                    })
                end
                if curVal == true and self.input_enabled == false then
                    self.input_enabled = true
                    msg.post(".", "acquire_input_focus")
                    print("Input enabled by server control")
                end
            end
        end
    end)
end

function update(self, dt)
    if self.is_connected and self.room and self.input_enabled and self.is_controllable and self.player_ready and (move_vector.x ~= 0 or move_vector.y ~= 0) then
        self.room:send("move", move_vector)
    end
    if self.is_connected and self.room and self.debug_timer and self.debug_timer > 0.25 then
        self.debug_timer = 0
        self.room:send("get_debug_bodies", {})
    else
        self.debug_timer = (self.debug_timer or 0) + dt
    end
    if debug_draw_enabled and debug_draw then
        debug_draw(self)
    end
end

function on_input(self, action_id, action)
    if action_id == hash("f1") and action.pressed then
        debug_draw_enabled = not debug_draw_enabled
        print("디버그 바디 표시:", debug_draw_enabled and "ON" or "OFF")
    end
    if not self.input_enabled or not self.is_controllable or not self.player_ready then
        return false
    end
    if keys[action_id] then
        local key = keys[action_id]
        if action.pressed then
            move_vector[key.axis] = key.value
        elseif action.released then
            move_vector[key.axis] = 0
        end
    end
    if move_vector.x ~= 0 and move_vector.y ~= 0 then
        local length = math.sqrt(move_vector.x * move_vector.x + move_vector.y * move_vector.y)
        move_vector.x = move_vector.x / length
        move_vector.y = move_vector.y / length
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("position_ready") then
        self.player_ready = true
        print("Player ready at position:", message.x, message.y)
        if self.is_connected and self.room then
            self.room:send("move", { x = 0, y = 0 })
            timer.delay(0.1, false, function()
                if self.is_connected and self.room then
                    self.room:send("position_sync", { x = message.x, y = message.y })
                end
            end)
        end
    end
end

function on_enable(self)
    reset_inputs()
end

function on_disable(self)
    reset_inputs()
end
